#!/usr/bin/env python3

import requests
import json
import argparse
import socket
from rich.console import Console
from rich.table import Table
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

console = Console()

class VulnerabilityChecker:
    def __init__(self, target):
        self.target = target
        
    def check_open_ports(self):
        console.print("[yellow]Checking common ports...[/yellow]")
        open_ports = []
        common_ports = [21, 22, 23, 25, 53, 80, 110, 443, 8080, 8443]
        
        for port in common_ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((self.target, port))
                if result == 0:
                    open_ports.append(port)
                    console.print(f"[green]Port {port}: OPEN[/green]")
                sock.close()
            except:
                pass
        return open_ports
    
    def check_ssl(self):
        console.print("[yellow]Checking SSL/TLS...[/yellow]")
        try:
            response = requests.get(f"https://{self.target}", timeout=5, verify=False)
            console.print("[green]HTTPS is available[/green]")
            return True
        except:
            console.print("[red]HTTPS not available[/red]")
            return False
    
    def check_paths(self):
        console.print("[yellow]Checking common paths...[/yellow]")
        vulnerabilities = []
        paths = ["/admin", "/robots.txt", "/login"]
        
        for path in paths:
            try:
                response = requests.get(f"http://{self.target}{path}", timeout=5)
                if response.status_code == 200:
                    vulnerabilities.append(f"Accessible: {path}")
                    console.print(f"[red]Found: {path}[/red]")
            except:
                pass
        return vulnerabilities
    
    def generate_report(self):
        console.print(f"[bold blue]Vulnerability Assessment for {self.target}[/bold blue]")
        
        open_ports = self.check_open_ports()
        ssl_enabled = self.check_ssl()
        vulns = self.check_paths()
        
        table = Table(title="Summary")
        table.add_column("Category", style="cyan")
        table.add_column("Finding", style="yellow")
        table.add_column("Risk", style="red")
        
        for port in open_ports:
            table.add_row("Open Ports", str(port), "Medium")
        
        if ssl_enabled:
            table.add_row("SSL", "HTTPS Available", "Low")
        else:
            table.add_row("SSL", "No HTTPS", "High")
        
        for vuln in vulns:
            table.add_row("Web", vuln, "High")
        
        console.print(table)

def main():
    parser = argparse.ArgumentParser(description="Vulnerability checker")
    parser.add_argument("--target", required=True, help="Target IP or domain")
    args = parser.parse_args()
    
    checker = VulnerabilityChecker(args.target)
    checker.generate_report()

if __name__ == "__main__":
    main()
